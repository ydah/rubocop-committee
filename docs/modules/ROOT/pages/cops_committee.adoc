////
  Do NOT edit this file by hand directly, as it is automatically generated.

  Please make any necessary changes to the cop documentation within the source files themselves.
////

= Committee

[#committeeassertschemaconformwithoutrequest]
== Committee/AssertSchemaConformWithoutRequest

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

Check if `assert_*_schema_conform` is called without making an HTTP request.

[#examples-committeeassertschemaconformwithoutrequest]
=== Examples

[source,ruby]
----
# bad
it 'conforms to schema' do
  assert_schema_conform(200)
end

# good
it 'conforms to schema' do
  get '/users'
  assert_schema_conform(200)
end
----

[#committeedeprecatedoldassertbehavior]
== Committee/DeprecatedOldAssertBehavior

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

Check if `committee_options` enables deprecated `old_assert_behavior`.

[#examples-committeedeprecatedoldassertbehavior]
=== Examples

[source,ruby]
----
# bad
def committee_options
  { schema_path: "schema.yaml", old_assert_behavior: true }
end

# good
def committee_options
  { schema_path: "schema.yaml", old_assert_behavior: false }
end
----

[#committeemultipleschemaconform]
== Committee/MultipleSchemaConform

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

Check for multiple schema conformance assertions within the same request block.

[#examples-committeemultipleschemaconform]
=== Examples

[source,ruby]
----
# bad
it 'returns users' do
  get '/users'
  assert_schema_conform(200)
  assert_response_schema_confirm(200)
end

# good
it 'returns users' do
  get '/users'
  assert_schema_conform(200)
end
----

[#committeeredundantresponsestatusassertions]
== Committee/RedundantResponseStatusAssertions

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| -
| -
|===

Check for validation of redundant response HTTP status codes.

[#examples-committeeredundantresponsestatusassertions]
=== Examples

[source,ruby]
----
# bad
it 'does something' do
  subject
  expect(response).to have_http_status 400
  assert_schema_conform(400)
end

# good
it 'does something' do
  subject
  assert_schema_conform(400)
end
----

[#committeeunspecifiedexpectedstatus]
== Committee/UnspecifiedExpectedStatus

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| Always
| -
| -
|===

Check if the status code is specified as an argument to the method of the Committee
where the expected response HTTP status code is required.

[#examples-committeeunspecifiedexpectedstatus]
=== Examples

[source,ruby]
----
# bad
it 'does something' do
  subject
  assert_schema_conform
end

# good
it 'does something' do
  subject
  assert_schema_conform(200)
end
----

[#committeeunusedschemacoverage]
== Committee/UnusedSchemaCoverage

|===
| Enabled by default | Safe | Supports autocorrection | Version Added | Version Changed

| Enabled
| Yes
| No
| -
| -
|===

Check for unused schema coverage setup without any report call.

[#examples-committeeunusedschemacoverage]
=== Examples

[source,ruby]
----
# bad
before do
  @schema_coverage = Committee::Test::SchemaCoverage.new(schema)
  @committee_options[:schema_coverage] = @schema_coverage
end

# good
before do
  @schema_coverage = Committee::Test::SchemaCoverage.new(schema)
  @committee_options[:schema_coverage] = @schema_coverage
end

after(:all) do
  @schema_coverage.report
end
----
